#This is the code for the main function that estimates the causal graph via CPCM, called CPCM_graph_estimate(X, family_of_distributions). 

#family_of_distributions correspond to the models we use. We implemented a joint CPCM(F1...Fk) model with the following:
#family1 = c('Gaussian with fixed sigma', 'Pareto',  'Poisson')
#family2 = c('Gaussian', 'Gamma', 'Negative_binomial')

#family_of_distributions = 1 if we use family1
#family_of_distributions = 2 if we use family2

#Rule of thumb is that we use family1 if n<=1000 and we use family2 if n>1000, but it should depend on the complexity of the dataset; that is, first try family1 and if all graphs are not plausible, use family2

#If you want to use CPCM(F) model, the choices for 'family_of_distributions' 
#are the following: "Gaussian", "Gaussian with fixed sigma", "Pareto", "Gamma", "Gamma with fixed scale", "Gumbel", "Gumbel with fixed scale"


#If you want different family than already coded or different method than implemented, it is easy! For that,
#simply add into function "estimate_epsilon(Y, X, family="YOUR DISTRIBUTION FUNCTION")" a code how you want to estimate your epsilons
#We always used "gam" function from "MGCV" package for the smooth parameter estimation. 


library(MASS)
library("mgcv")
library("gamlss")
library(dHSIC)
library(rje)
library(stringr)
library(EnvStats)
library(dplyr)
library(copula)
library(bnlearn)
library(Hmisc)

##################################   Example   ###########################################
n=1000
X1 = rnorm(n)
X2=c();
for (i in 1:n) {
  X2 = c(X2, rnorm(1,X1[i]^2,1))
}
X= data.frame(X1, X2)
CPCM_graph_estimate(X, family_of_distributions = 'Sequential choice') 

plot(X)
############################ CPCM estimation of the causal graph ##########################


CPCM_graph_estimate <- function(X, family_of_distributions = 1){  
  n = length(X[,1])
  lambda = 2 #penalty for more edges
  
  
  #Estimation \hat{S}
  estimate_support_of_X_and_pair_a_family_for_X<-function(X, family_of_distributions = 1){
    
    determine_support <- function(X) {
      
      # Check if the data is discrete (integer values only)
      if (all(X == floor(X)) & length(unique(X))< length(X)/10) {
        return('discrete')  # Poisson distribution
      }
      
      # Check if the data is within the interval [0, 1]
      if (all(X >= 0 & X <= 1)) {
        return('interval')  # Beta distribution
      }
      
      # Check for Gamma distribution characteristics
      if (all(X > 0)) {
        # Check for skewness to differentiate from Gaussian
        skewness <- mean((X - mean(X))^3) / (mean((X - mean(X))^2)^(3/2))
        if (skewness > 0) {
          return('half-line')  # Gamma distribution
        }
      }
      
      # If none of the above conditions are met, assume Gaussian
      return('full support')  # Gaussian distribution
    }
    
    if(family_of_distributions == 1){
      if( determine_support(X)=='full support') return('Gaussian with fixed sigma')
      if( determine_support(X)=='discrete') return('Poisson')
      if( determine_support(X)=='interval') return('Gaussian with fixed sigma') #Beta distribution is no longer supported
      if( determine_support(X)=='half-line') return('Pareto')
    }
    
    if(family_of_distributions == 2){
      if( determine_support(X)=='full support') return('Gaussian')
      if( determine_support(X)=='discrete') return('Negative_binomial')
      if( determine_support(X)=='interval') return('Gaussian') #Beta distribution is no longer supported
      if( determine_support(X)=='half-line') return('Gamma')
    }
    
    
  }
  
  estimate_epsilon <- function(Y, X, family = "Gaussian", method = "smooth") {
    
    # --- Helper: Rename X columns to X1, X2, ...
    rename_columns <- function(X) {
      if (is.null(nrow(X))) {
        X <- as.data.frame(X)
        names(X)[1] <- "X1"
      } else {
        names(X) <- paste0("X", seq_along(X))
      }
      return(X)
    }
    
    # --- Helper: Construct GAM formula based on method and variable type
    construct_formula <- function(X, include_Y = TRUE, method = "smooth") {
      terms <- sapply(seq_along(X), function(i) {
        xi <- X[[i]]
        if (length(unique(xi)) <= 9) {
          paste0("as.factor(X", i, ")")
        } else if (method == "smooth") {
          paste0("s(X", i, ")")
        } else {
          paste0("X", i)
        }
      })
      rhs <- paste(terms, collapse = " + ")
      as.formula(if (include_Y) paste("Y ~", rhs) else paste("~", rhs))
    }
    
    # --- Data preparation
    X <- rename_columns(X)
    Y <- setNames(as.data.frame(Y), "Y")
    data <- cbind(Y, X)
    
    # --- Reuse formulas
    formula_mu <- construct_formula(X, include_Y = TRUE, method = method)
    formula_sigma <- construct_formula(X, include_Y = FALSE, method = method)
    
    # --- Dispatcher via switch
    residuals <- switch(family,
                        
                        "Gaussian" = {
                          fit <- gam(list(formula_mu, formula_sigma), data = data, family = gaulss(), link = list("identity", "logb"))
                          mu <- fit$fitted.values[, 1]
                          inv_sigma <- fit$fitted.values[, 2]
                          pnorm((Y$Y - mu) * inv_sigma)
                        },
                        
                        "Gaussian with fixed sigma" = {
                          fit <- gam(list(formula_mu, ~1), data = data, family = gaulss(), link = list("identity", "logb"))
                          mu <- fit$fitted.values[, 1]
                          inv_sigma <- fit$fitted.values[, 2]
                          pnorm((Y$Y - mu) * inv_sigma)
                        },
                        
                        "Gamma" = {
                          fit <- gam(list(formula_mu, formula_sigma), data = data, family = gammals())
                          shape <- 1 / exp(fit$fitted.values[, 2])
                          scale <- fit$fitted.values[, 1] * exp(fit$fitted.values[, 2])
                          pgamma(Y$Y, shape = shape, scale = scale)
                        },
                        
                        "Gamma with fixed scale" = {
                          fit <- gam(list(formula_mu, ~1), data = data, family = gammals())
                          shape <- 1 / exp(fit$fitted.values[, 2])
                          scale <- fit$fitted.values[, 1] * exp(fit$fitted.values[, 2])
                          pgamma(Y$Y, shape = shape, scale = scale)
                        },
                        
                        "Gumbel" = {
                          fit <- gam(list(formula_mu, formula_sigma), data = data, family = gumbls())
                          mu <- fit$fitted.values[, 1]
                          scale <- exp(fit$fitted.values[, 2])
                          pgumbel <- function(x, location = 0, scale = 1) {exp(-exp(-(x - location) / scale))}
                          pgumbel(Y$Y, mu, scale)
                        },
                        
                        "Gumbel with fixed scale" = {
                          fit <- gam(list(formula_mu, ~1), data = data, family = gumbls())
                          mu <- fit$fitted.values[, 1]
                          scale <- exp(fit$fitted.values[, 2])
                          pgumbel <- function(x, location = 0, scale = 1) {exp(-exp(-(x - location) / scale))}
                          pgumbel(Y$Y, mu, scale)
                        },
                        
                        "Pareto" = {
                          data$Y <- -log(log(Y$Y))
                          fit <- gam(list(formula_mu, ~1), data = data, family = gumbls())
                          pgumbel <- function(x, location = 0, scale = 1) {exp(-exp(-(x - location) / scale))}
                          pgumbel( data$Y , fit$fitted.values[, 1], 1)
                        },
                        
                        "Pareto2" = {
                          data$Y <- -log(log(Y$Y))
                          fit <- gam(list(formula_mu, ~formula_sigma), data = data, family = gumbls())
                          pgumbel <- function(x, location = 0, scale = 1) {exp(-exp(-(x - location) / scale))}
                          pgumbel( data$Y , fit$fitted.values[, 1], 1)
                        },
                        
                        "Poisson" = {
                          fit <- gam(formula_mu, data = data, family = poisson())
                          ppois(Y$Y, lambda = fitted(fit))
                        },
                        
                        "Negative_binomial" = {
                          if (ncol(X) > 1) warning("Negative_binomial supports only one covariate; using X1 only.")
                          fit <- gam(Y$Y ~ s(X$X1), data = data, family = nb())
                          pnbinom(Y$Y, mu = fitted(fit), size = fit$family$getTheta(TRUE))
                        },
                        
                        stop("Family not implemented.")
    )
    
    return(residuals)
  }
  
  
  create_bivariate_output_from_p_values <- function(indep, z1, z2, family1, family2) {
    #Score-based graph estimate
    empty = -log(indep) 
    one = -log(z1) + lambda
    two = -log(z2) + lambda
    if (empty < one & empty < two) {res1 = "Empty graph"} else if (one < two) {res1 = "1 --> 2"} else {res1 = "2 --> 1"}
    
    #Testing estimate
    res2=res1
    if(indep>0.05) {res2 = "Empty graph"}else{
      if (z1>0.05 & z2>0.05) res2 = "Unidentifiable  (both directions are plausible)" 
      if (z1<0.05 & z2<0.05) res2 = "Assumptions not fulfilled (both directions are not plausible)"
      if (z1<0.05 & z2>0.05) res2 = "2 --> 1"
      if (z1>0.05 & z2<0.05) res2 = "1 --> 2"
    }
    
    #Forced estimate
    if(z1>=z2) {res3 = "1 --> 2"} else {res3 = "2 --> 1"}
    
    res=as.data.frame(c(round(indep, digits=6), round(z1, digits=6), round(z2, digits = 6), res1, res2, res3, paste0(family1, ";", family2)))
    colnames(res)<-c("Results")
    rownames(res)<-c("p-value Empty graph", "p-value 1-->2", "p-value 2-->1", "Score-based graph estimate", 'Testing estimate', 'Forced estimate', 'Families used' )
    return(res)}
  

  bivariate_CPCM_graph_estimate <- function(X, family_of_distributions = 1){
    
    #Are X1 and X2 idependent? If yes, we return an empty graph as an estimate
    X1 = X[,1]; X2 = X[,2]
    indep=dhsic.test(data.frame(X1, X2), method = 'gamma')$p.value
    
    
    #X1-->X2 direction
    Y = X2; X_=data.frame(X1 = X1)
    if(family_of_distributions == 1 || family_of_distributions==2)
    {family2 = estimate_support_of_X_and_pair_a_family_for_X(Y, family_of_distributions = family_of_distributions)}else{family2 = family_of_distributions}
    r2=as.numeric(estimate_epsilon(Y, X_, family = family2))
    
    #X2-->X1 direction
    Y= X1; X_=data.frame(X1 = X2)
    if(family_of_distributions == 1 || family_of_distributions==2)
    {family1 = estimate_support_of_X_and_pair_a_family_for_X(Y, family_of_distributions = family_of_distributions)}else{family1 = family_of_distributions}
    r1= as.numeric(estimate_epsilon(Y, X_, family = family1))
    
    #Which independence test should we choose? hoeffding.D.test or dhsic.test? hoeffding.D.test does not work well for discrete variables, but is faster
    z1=dhsic.test(data.frame(r2, X1), method = 'gamma')$p.value
    z2=dhsic.test(data.frame(r1, X2), method = 'gamma')$p.value
    
    
   
    return(create_bivariate_output_from_p_values(indep, z1, z2, family1, family2))
  }
  
  
  
  trivariate_exact_CPCM_graph_estimate <- function(X, family_of_distributions = 1){
    showing_computing_time=TRUE #Change to FALSE if annoyed by showing the remaining time when computing
    
    make_all_dags_on_three_nodes <-function(){#I am sorry about this monstrosity. Thanks chatGPT for generating it, it was easier
      all_dags = list()
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,0,   0,0,0,    0,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,1,0,   0,0,0,    0,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,1,0,   0,0,1,    0,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,1,0,   0,0,0,    0,1,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,1,0,   0,0,0,    1,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,1,0,   0,0,0,    1,1,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,1,1,   0,0,0,    0,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,1,1,   0,0,1,    0,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,1,1,   0,0,0,    0,1,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,1,   0,0,1,    0,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,1,   0,0,0,    0,1,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,1,   1,0,0,    0,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,1,   1,0,1,    0,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,1,   0,0,0,    0,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,0,   1,0,0,    0,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,0,   0,0,1,    0,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,0,   0,0,0,    1,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,0,   0,0,0,    0,1,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,0,   1,0,0,    0,1,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,0,   1,0,0,    1,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,0,   1,0,0,    1,1,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,0,   1,0,1,    0,1,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,0,   0,0,0,    1,1,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,0,   1,0,1,    1,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      all_dags[[length(all_dags)+1]] = matrix(c(0,0,0,   1,0,1,    0,0,0), nrow = 3, ncol = 3, byrow = TRUE)
      
      return(all_dags)}
    all_dags = make_all_dags_on_three_nodes()
    
    from_matrix_to_values<-function(variable, dag){
      if (variable ==1) {
        if (all(dag[,variable]==c(0,0,0))) {return(1)}
        else if (all(dag[,variable]==c(0,1,0))) {return(2)}
        else if (all(dag[,variable]==c(0,0,1))) {return(3)}
        else if (all(dag[,variable]==c(0,1,1))) {return(4)}
      }
      if (variable ==2) {
        if (all(dag[,variable]==c(0,0,0))) {return(1)}
        else if (all(dag[,variable]==c(1,0,0))) {return(2)}
        else if (all(dag[,variable]==c(0,0,1))) {return(3)}
        else if (all(dag[,variable]==c(1,0,1))) {return(4)}
      }  
      if (variable ==3) {
        if (all(dag[,variable]==c(0,0,0))) {return(1)}
        else if (all(dag[,variable]==c(1,0,0))) {return(2)}
        else if (all(dag[,variable]==c(0,1,0))) {return(3)}
        else if (all(dag[,variable]==c(1,1,0))) {return(4)}
      }  
      
      
    }
    res=c(); #res = final result
    ##################We coded it only for d=2 and d=3 using ugly brute-force
    
    #TRIVARIATE CASE
    if (ncol(X)==3) {
      X1 = X[,1]; X2 = X[,2]; X3 = X[,3]
      
      
      
      
      if(family_of_distributions == 1 || family_of_distributions==2)
      {family1 = estimate_support_of_X_and_pair_a_family_for_X(X1, family_of_distributions = family_of_distributions)
      family2 = estimate_support_of_X_and_pair_a_family_for_X(X2, family_of_distributions = family_of_distributions)
      family3 = estimate_support_of_X_and_pair_a_family_for_X(X3, family_of_distributions = family_of_distributions)
      }else{
        family1 = family_of_distributions
        family2 = family_of_distributions
        family3 = family_of_distributions}
      
      
      r123=as.numeric( estimate_epsilon(Y= X1, X=data.frame(X1=  X2  , X2=  X3  ), family = family1) )
      r12=as.numeric(estimate_epsilon(Y= X1, X=data.frame(X1=  X2   ), family = family1) )
      r13=as.numeric(estimate_epsilon(Y= X1, X=data.frame(X1=   X3  ), family = family1) )
      
      r213=as.numeric(estimate_epsilon(Y= X2, X=data.frame(X1=  X1  , X2=  X3  ), family = family2) )
      r21=as.numeric(estimate_epsilon(Y= X2, X=data.frame(X1=  X1   ), family = family2) )
      r23=as.numeric(estimate_epsilon(Y= X2, X=data.frame(X1=  X3  ), family = family2) )
      
      r312=as.numeric(estimate_epsilon(Y= X3, X=data.frame(X1=  X1  , X2=  X2  ), family = family3) )
      r31 =as.numeric(estimate_epsilon(Y= X3, X=data.frame(X1=  X1 ), family = family3) )
      r32 =as.numeric(estimate_epsilon(Y= X3, X=data.frame(X1=  X2 ), family = family3) )
      
      
      A = data.frame(X1, r12, r13, r123)
      B = data.frame(X2, r21, r23, r213)
      C = data.frame(X3, r31, r32, r312)
      
      p_values = c(); p_values_adjusted = c()
      k = length(all_dags)
      for (i in 1:length(all_dags)) {
        if(showing_computing_time==TRUE){cat("Time remaining:",k, "\n"); k=k-1}
        dag = all_dags[[i]]
        p_value =  dhsic.test(data.frame(A[from_matrix_to_values(1,dag)], 
                                         B[from_matrix_to_values(2, dag)], 
                                         C[from_matrix_to_values(3, dag)]) , 
                              method = 'gamma')$p.value
        if(p_value<=accuracy){p_value = 0}
        p_values = c(p_values,  p_value)
        p_values_adjusted = c(p_values_adjusted, -log(p_value) + lambda*sum(dag))
      }
      
      M_best = all_dags[[ which.min(p_values_adjusted)    ]]
      M_plausible = list()
      plausible = 1:length(all_dags); plausible = plausible[p_values>0.01]
      for (i in which(p_values > 0.01)[order(p_values_adjusted[plausible])]) {
        M_plausible = c(M_plausible, list(all_dags[[i]]))
      }
      
      
      return(list(plausible=M_plausible, p_values=p_values, p_values_adjusted=p_values_adjusted, result=M_best))
      
    }
    
  }
  
  
  greedy_CPCM_graph_estimate <- function(X, family_of_distributions = 1, quiet = FALSE) {
    
    
    CPCM_score_function <- function(X, dag) {
      
      epsilon = X
      nodes <- colnames(X)
      d = length(nodes)
      for (i in 1:d) {
        node <- nodes[i]
        parents <- parents(dag, node)
        if (length(parents) > 0) {
          if(family_of_distributions==1 || family_of_distributions ==2){family_for_Y = estimate_support_of_X_and_pair_a_family_for_X(X[, node], family_of_distributions)}else{family_for_Y = family_of_distributions}
          e = estimate_epsilon(Y = X[, node], X = data.frame(X[, parents]), family = family_for_Y)
          epsilon[, node] <- e
        }
      }
      
      p_value =  dhsic.test(epsilon, method = 'gamma')$p.value
      return(-log(p_value) + lambda*nrow(arcs(dag)) )  # Score based on number of edges (simplistic example)
    }
    
    # Function to check if an arc exists in a DAG
    arc_exists <- function(dag, from, to) {
      arcs_list <- arcs(dag)
      return(any(arcs_list[, 1] == from & arcs_list[, 2] == to))
    }
    
    score_function = CPCM_score_function
    #stupid_score_function <- function(X, dag) {return(-length(arcs(dag)))}
    nodes <- colnames(X)
    current_dag <- empty.graph(nodes)
    best_score <- score_function(X, current_dag)
    if(quiet == FALSE){cat('Score = ', best_score, 'DAG = Empty', '\n')}
    
    improved <- TRUE
    while (improved) {
      improved <- FALSE
      candidate_dags <- list()
      candidate_scores <- numeric()
      
      # Generate candidate DAGs by adding/removing edges
      for (i in 1:length(nodes)) {
        for (j in 1:length(nodes)) {
          if (i != j) {
            new_dag <- current_dag
            
            if (!arc_exists(new_dag, nodes[i], nodes[j])) {
              temp_dag <- tryCatch(
                set.arc(new_dag, nodes[i], nodes[j], check.cycles = TRUE),
                error = function(e) NULL  # Skip invalid arcs
              )
              if (is.null(temp_dag)) next  # Skip if cycle is created
              new_dag <- temp_dag
            } else {
              new_dag <- drop.arc(new_dag, nodes[i], nodes[j])  # Remove edge
            }
            
            new_score <- score_function(X, new_dag)
            candidate_dags <- append(candidate_dags, list(new_dag))
            candidate_scores <- c(candidate_scores, new_score)
            if(quiet == FALSE){cat('Score = ', new_score, 'DAG = ', new_dag$arcs, '\n')}
          }
        }
      }
      
      # Select the DAG with the lowest score
      if (length(candidate_scores) > 0 && min(candidate_scores) < best_score) {
        best_index <- which.min(candidate_scores)
        current_dag <- candidate_dags[[best_index]]
        best_score <- candidate_scores[best_index]
        improved <- TRUE
      }
    }
    
    return(current_dag)
  }
  
  
  
  if(ncol(X)==2) {
    if(family_of_distributions!='Sequential choice'){
      return(bivariate_CPCM_graph_estimate(X, family_of_distributions=family_of_distributions))}
    
    if(family_of_distributions=='Sequential choice'){
      alpha_level = 0.01
      
      result1 = bivariate_CPCM_graph_estimate(X, family_of_distributions = 1)
      if(max(result1[[1]][1:3])>alpha_level){return(result1)}else{
      result2 = bivariate_CPCM_graph_estimate(X, family_of_distributions = 2)
      if(max(result2[[1]][1:3])>alpha_level){return(result2)}else{
      result3 = result2
      result3[[1]][1] = max(result1[[1]][1], result2[[1]][1])
      result3[[1]][2] = max(result1[[1]][2], result2[[1]][2])
      result3[[1]][3] = max(result1[[1]][3], result2[[1]][3])
    
      family1 = sub(";.*", "", result2[[1]][7])
      family2 = sub(".*?;", "", result2[[1]][7])
      if(result1[[1]][2]>result2[[1]][2]){family1 = sub(";.*", "", result1[[1]][7])}
      if(result1[[1]][3]>result2[[1]][3]){family2 = sub(".*?;", "", result1[[1]][7])}
      
      result=create_bivariate_output_from_p_values(as.numeric(result3[[1]][1]), 
                                         as.numeric(result3[[1]][2]), 
                                         as.numeric(result3[[1]][3]),
                                         family1, family2)
        return(result)
      }
    }
  } 
}
if(ncol(X)==3) return(trivariate_exact_CPCM_graph_estimate(X, family_of_distributions=family_of_distributions))
if(ncol(X)>3) return(greedy_CPCM_graph_estimate(X, family_of_distributions=family_of_distributions, quiet = TRUE))

}  








